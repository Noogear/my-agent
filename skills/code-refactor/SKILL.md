---
name: code-refactor
description: "Multi-language code refactoring and cleanup expert. Supports any programming language. Use for: (1) Review methods/functions, group by functionality, create utility modules (2) Eliminate duplicate code, extract common logic (3) Reorganize package/module structure (4) Clean up comments, keep only essential docs. CRITICAL: Before any refactoring, ALWAYS generate an interactive checklist for user approval. Trigger words: refactor, clean code, organize code, group methods, extract utility, clean comments, simplify code, code optimization, package restructure, reorganize, eliminate duplication, DRY principle."
---

# Code Refactor - Interactive Refactoring & Cleanup

## Phase 0: Context Discovery (CRITICAL)

Before generating the refactoring checklist, gather context from:

### 0.1 Detect Language and Framework

Detect project language/framework from file extensions and project files:
- `pom.xml`, `build.gradle` â†’ Java/Kotlin (Gradle/Maven)
- `package.json` â†’ JavaScript/TypeScript (Node.js)
- `pyproject.toml`, `setup.py` â†’ Python
- `Cargo.toml` â†’ Rust
- `go.mod` â†’ Go
- `*.csproj` â†’ C#

### 0.2 Read Project Configuration Files

**MUST read these files if they exist** to understand project-specific rules:

| Config File | Purpose | Key Rules to Extract |
|-------------|---------|---------------------|
| `checkstyle.xml` | Code style | Line length, naming conventions, import order |
| `.eslintrc.*` | Linting rules | Complexity limits, naming patterns |
| `.prettierrc` | Formatting | Quote style, semicolons, line width |
| `pyproject.toml` | Python config | Line length, import sorting (isort) |
| `.editorconfig` | Editor settings | Indent style, charset, line endings |
| `tslint.json` | TS linting | Deprecated but may exist |
| `rustfmt.toml` | Rust formatting | Max width, imports granularity |
| `styleguide.md` | Custom rules | Project-specific conventions |

**Action**: Read detected config files and incorporate their rules into checklist generation.

### 0.3 Read Related Skills

Check if workspace has related skill files or project instructions that may contain refactoring guidelines:

| Skill/File | When to Read |
|------------|--------------|
| `.github/copilot-instructions.md` | Always check first |
| `CONTRIBUTING.md` | For naming/structure conventions |
| Language-specific skills | Based on detected language |

**Action**: If related skills exist, read them for domain-specific patterns and best practices.

### 0.4 Load Language-Specific References

Based on detected language, load appropriate reference files from `references/<language>/`:

```
references/
â”œâ”€â”€ java/           # Java-specific patterns
â”œâ”€â”€ typescript/     # TypeScript-specific patterns (future)
â”œâ”€â”€ python/         # Python-specific patterns (future)
â””â”€â”€ kotlin/         # Kotlin-specific patterns (future)
```

---

## Phase 1: Refactoring Plan File Workflow

**ALWAYS create a plan file BEFORE performing any refactoring operations.**

### Step 1: Create Plan File

After gathering context, scan the target code and **create a markdown file** in the project root:

**File Location**: `{project_root}/.refactor-plan.md`

**Why a file?**
- User can edit directly in their editor
- Checkbox state is preserved
- Easy to review diffs
- Can be version controlled if needed

### Step 2: Generate Plan Content

Create the file with the following structure. **Use the user's language** (detected from conversation).

#### File Header (Required)

```markdown
<!-- 
  REFACTORING PLAN - Auto-generated by code-refactor skill
  
  Instructions:
  - [x] = Will execute (checked)
  - [ ] = Will skip (unchecked)
  - Edit freely: add/remove/modify items
  - Save the file when done
  - Reply "Proceed" / "ç»§ç»­" to execute
  - Reply "Cancel" / "å–æ¶ˆ" to abort
  
  This file will be DELETED after refactoring completes.
-->
```

#### English Template

```markdown
<!-- REFACTORING PLAN -->

# ğŸ“‹ Refactoring Plan

> Edit this file to customize the refactoring. Uncheck items to skip.
> Save and reply **"Proceed"** when ready.

## 1. Quick Wins (Low Risk) âœ¨

- [x] **1.1 Remove unused imports** â€” `{file}` ({count} unused)
- [x] **1.2 Remove unused variables** â€” `{varName}` in `{function}()`
- [x] **1.3 Remove dead code** â€” Lines {start}-{end} in `{file}`
- [x] **1.4 Extract magic numbers** â€” `{value}` â†’ `{CONSTANT_NAME}`

## 2. Code Smell Fixes (Medium Risk) ğŸ”§

### 2.1 Long Methods/Functions
- [x] **2.1.1 Split `{functionName}()`** â€” {lines} lines â†’ extract `{newFunc1}()`, `{newFunc2}()`
- [x] **2.1.2 Reduce nesting in `{functionName}()`** â€” {levels} levels â†’ extract branches

### 2.2 Duplicate Code
- [x] **2.2.1 Merge duplicate logic** â€” `{file1}:{line1}` â‰ˆ `{file2}:{line2}`
- [x] **2.2.2 Extract common pattern** â€” Found in {count} locations

### 2.3 Long Parameter Lists
- [x] **2.3.1 Introduce parameter object** â€” Replace `({params})` in {count} functions

## 3. Structure Improvements (Medium-High Risk) ğŸ—ï¸

### 3.1 Function/Method Grouping
- [x] **3.1.1 Extract `{UtilName}`** â€” {count} static functions from `{source}`
- [x] **3.1.2 Extract `{HelperName}`** â€” {count} helper functions from `{source}`

### 3.2 Class/Module Extraction
- [x] **3.2.1 Extract `{ClassName}`** â€” {description}
- [x] **3.2.2 Extract interface/protocol** â€” Decouple `{dependency}`

## 4. Package/Module Reorganization (High Risk) ğŸ“¦

- [x] **4.1 Move `{file}`** â€” `{oldPath}` â†’ `{newPath}`
- [x] **4.2 Create `{folderName}/` directory** â€” Move {count} related files

## 5. Documentation Cleanup (Low Risk) ğŸ“

- [x] **5.1 Simplify verbose docs** â€” `{file}` ({before} lines â†’ {after} lines)
- [x] **5.2 Remove redundant tags** â€” {count} files
- [x] **5.3 Add missing docs** â€” {count} public APIs need documentation

---

## Custom Items (Add Your Own)

<!-- Add custom refactoring items here -->
- [ ] **Custom.1** â€” Description here

---

**Reply:**
- âœ… `Proceed` â€” Execute all checked items
- âŒ `Cancel` â€” Abort and delete this file
```

#### ä¸­æ–‡æ¨¡æ¿

```markdown
<!-- é‡æ„è®¡åˆ’ -->

# ğŸ“‹ é‡æ„è®¡åˆ’

> ç¼–è¾‘æ­¤æ–‡ä»¶ä»¥è‡ªå®šä¹‰é‡æ„ã€‚å–æ¶ˆå‹¾é€‰ä»¥è·³è¿‡é¡¹ç›®ã€‚
> ä¿å­˜åå›å¤ **"ç»§ç»­"** å¼€å§‹æ‰§è¡Œã€‚

## 1. å¿«é€Ÿä¿®å¤ï¼ˆä½é£é™©ï¼‰âœ¨

- [x] **1.1 åˆ é™¤æœªä½¿ç”¨çš„å¯¼å…¥** â€” `{file}`ï¼ˆ{count} ä¸ªæœªä½¿ç”¨ï¼‰
- [x] **1.2 åˆ é™¤æœªä½¿ç”¨çš„å˜é‡** â€” `{function}()` ä¸­çš„ `{varName}`
- [x] **1.3 åˆ é™¤æ­»ä»£ç ** â€” `{file}` ç¬¬ {start}-{end} è¡Œ
- [x] **1.4 æå–é­”æ³•æ•°å­—** â€” `{value}` â†’ `{CONSTANT_NAME}`

## 2. ä»£ç å¼‚å‘³ä¿®å¤ï¼ˆä¸­ç­‰é£é™©ï¼‰ğŸ”§

### 2.1 è¿‡é•¿æ–¹æ³•/å‡½æ•°
- [x] **2.1.1 æ‹†åˆ† `{functionName}()`** â€” {lines} è¡Œ â†’ æå– `{newFunc1}()`ã€`{newFunc2}()`
- [x] **2.1.2 å‡å°‘ `{functionName}()` åµŒå¥—** â€” {levels} å±‚ â†’ æå–åˆ†æ”¯

### 2.2 é‡å¤ä»£ç 
- [x] **2.2.1 åˆå¹¶é‡å¤é€»è¾‘** â€” `{file1}:{line1}` â‰ˆ `{file2}:{line2}`
- [x] **2.2.2 æå–é€šç”¨æ¨¡å¼** â€” åœ¨ {count} å¤„å‘ç°

### 2.3 è¿‡é•¿å‚æ•°åˆ—è¡¨
- [x] **2.3.1 å¼•å…¥å‚æ•°å¯¹è±¡** â€” æ›¿æ¢ {count} ä¸ªå‡½æ•°ä¸­çš„ `({params})`

## 3. ç»“æ„æ”¹è¿›ï¼ˆä¸­é«˜é£é™©ï¼‰ğŸ—ï¸

### 3.1 å‡½æ•°/æ–¹æ³•åˆ†ç»„
- [x] **3.1.1 æå– `{UtilName}`** â€” ä» `{source}` æå– {count} ä¸ªé™æ€å‡½æ•°
- [x] **3.1.2 æå– `{HelperName}`** â€” ä» `{source}` æå– {count} ä¸ªè¾…åŠ©å‡½æ•°

### 3.2 ç±»/æ¨¡å—æå–
- [x] **3.2.1 æå– `{ClassName}`** â€” {description}
- [x] **3.2.2 æå–æ¥å£/åè®®** â€” è§£è€¦ `{dependency}`

## 4. åŒ…/æ¨¡å—é‡ç»„ï¼ˆé«˜é£é™©ï¼‰ğŸ“¦

- [x] **4.1 ç§»åŠ¨ `{file}`** â€” `{oldPath}` â†’ `{newPath}`
- [x] **4.2 åˆ›å»º `{folderName}/` ç›®å½•** â€” ç§»åŠ¨ {count} ä¸ªç›¸å…³æ–‡ä»¶

## 5. æ–‡æ¡£æ¸…ç†ï¼ˆä½é£é™©ï¼‰ğŸ“

- [x] **5.1 ç®€åŒ–å†—é•¿æ–‡æ¡£** â€” `{file}`ï¼ˆ{before} è¡Œ â†’ {after} è¡Œï¼‰
- [x] **5.2 åˆ é™¤å†—ä½™æ ‡ç­¾** â€” {count} ä¸ªæ–‡ä»¶
- [x] **5.3 è¡¥å……ç¼ºå¤±æ–‡æ¡£** â€” {count} ä¸ªå…¬å…± API éœ€è¦æ–‡æ¡£

---

## è‡ªå®šä¹‰é¡¹ç›®ï¼ˆæ·»åŠ ä½ è‡ªå·±çš„ï¼‰

<!-- åœ¨æ­¤æ·»åŠ è‡ªå®šä¹‰é‡æ„é¡¹ç›® -->
- [ ] **è‡ªå®šä¹‰.1** â€” æè¿°

---

**å›å¤ï¼š**
- âœ… `ç»§ç»­` â€” æ‰§è¡Œæ‰€æœ‰å·²å‹¾é€‰é¡¹ç›®
- âŒ `å–æ¶ˆ` â€” ä¸­æ­¢å¹¶åˆ é™¤æ­¤æ–‡ä»¶
```

### Step 3: Notify User

After creating the file, inform the user:

**English:**
```
ğŸ“‹ Refactoring plan created: `.refactor-plan.md`

Please review and edit the plan:
1. Open `.refactor-plan.md` in your editor
2. Uncheck `[x]` â†’ `[ ]` items you want to skip
3. Add custom items if needed
4. Save the file
5. Reply "Proceed" to execute, or "Cancel" to abort
```

**ä¸­æ–‡ï¼š**
```
ğŸ“‹ é‡æ„è®¡åˆ’å·²åˆ›å»ºï¼š`.refactor-plan.md`

è¯·å®¡æŸ¥å¹¶ç¼–è¾‘è®¡åˆ’ï¼š
1. åœ¨ç¼–è¾‘å™¨ä¸­æ‰“å¼€ `.refactor-plan.md`
2. å–æ¶ˆå‹¾é€‰ `[x]` â†’ `[ ]` è¦è·³è¿‡çš„é¡¹ç›®
3. æ ¹æ®éœ€è¦æ·»åŠ è‡ªå®šä¹‰é¡¹ç›®
4. ä¿å­˜æ–‡ä»¶
5. å›å¤"ç»§ç»­"æ‰§è¡Œï¼Œæˆ–"å–æ¶ˆ"ä¸­æ­¢
```

### Step 4: Wait for User Response

**DO NOT proceed until user explicitly confirms.**

| User Response | Action |
|---------------|--------|
| "Proceed" / "ç»§ç»­" / "OK" / "Go" | Read file, execute checked items |
| "Cancel" / "å–æ¶ˆ" / "Abort" | Delete file, abort refactoring |
| Other questions | Answer without executing |

### Step 5: Parse Plan File

When user confirms, read `.refactor-plan.md` and parse:

```
- [x] item â†’ Execute this item
- [ ] item â†’ Skip this item
```

**Parsing rules:**
- Lines starting with `- [x]` or `- [X]` â†’ Execute
- Lines starting with `- [ ]` â†’ Skip
- Custom items in "Custom Items" section â†’ Execute if checked
- Ignore HTML comments and headers

### Step 6: Execute and Cleanup

1. Execute all checked items in priority order
2. After ALL items complete successfully:
   ```
   Delete file: .refactor-plan.md
   ```
3. Report completion summary

**If execution fails:**
- Keep the file for reference
- Report which items failed
- User can fix and retry

---

## Phase 2: Execution Priority

Execute in this order for safest refactoring:

```
1. Documentation cleanup (lowest risk)
2. Extract constants/magic numbers
3. Rename for clarity
4. Extract functions/methods (same file)
5. Move functions/methods (between files)
6. Extract utility classes/modules
7. Class responsibility reorganization â† NEW
8. Package/module restructure (highest impact)
```

---

## Phase 2.5: Class Responsibility Reorganization (FINAL STEP)

**Execute AFTER all other refactoring, BEFORE final validation.**

### Purpose

Ensure each class/module has a single, clear responsibility (Single Responsibility Principle).

### Analysis Steps

1. **List all classes/modules** in the refactored scope
2. **Identify class responsibility** by examining:
   - Class name suffix (Utils, Service, Handler, etc.)
   - Public methods purpose
   - Dependencies and collaborators
3. **Detect misplaced classes** â€” classes in wrong package/directory
4. **Generate move plan** in the refactor plan file

### Responsibility Detection Rules

| Pattern | Expected Location | Detection |
|---------|-------------------|-----------|
| `*Utils`, `*Helper` | `util/` or `utils/` | All static methods, no state |
| `*Service` | `service/` | Business logic, orchestration |
| `*Repository`, `*Dao` | `repository/` or `dao/` | Data access |
| `*Controller`, `*Handler` | `controller/` or `handler/` | Request handling |
| `*Config`, `*Configuration` | `config/` | Configuration classes |
| `*Factory` | `factory/` | Object creation |
| `*Builder` | `builder/` | Fluent builders |
| `*Validator` | `validator/` | Validation logic |
| `*Converter`, `*Mapper` | `converter/` | Type conversion |
| `*Exception` | `exception/` | Custom exceptions |
| `*Event`, `*Listener` | `event/` | Event system |
| `*DTO`, `*VO`, `*Entity` | `model/` or `dto/` | Data objects |
| `interface *` (API contract) | `api/` | Public interfaces |
| `*Impl` | `impl/` | Interface implementations |

### Move Decision Flow

```
For each class in scope:
  1. Extract responsibility from class name/content
  2. Determine expected package based on responsibility
  3. If current package â‰  expected package:
     â†’ Add to move plan
  4. If class has multiple responsibilities:
     â†’ Add to split plan (extract new class)
```

### Plan File Format (Append to .refactor-plan.md)

```markdown
## 6. Class Responsibility Reorganization ğŸ¯

### 6.1 Classes to Move
- [x] **6.1.1 Move `StringUtils`** â€” `com.app.core` â†’ `com.app.util` (utility class)
- [x] **6.1.2 Move `UserDTO`** â€” `com.app.service` â†’ `com.app.model` (data object)
- [x] **6.1.3 Move `ConfigException`** â€” `com.app` â†’ `com.app.exception` (exception class)

### 6.2 Classes to Split (Multiple Responsibilities)
- [x] **6.2.1 Split `ConfigurationManager`**
  - Keep: config loading/saving logic
  - Extract: `ConfigurationCache` (caching logic)
  - Extract: `ConfigurationValidator` (validation logic)

### 6.3 Packages to Create
- [x] **6.3.1 Create `util/`** â€” for utility classes
- [x] **6.3.2 Create `exception/`** â€” for exception classes
```

### Execution Order

```
1. Create new packages/directories first
2. Move simple classes (no dependencies on other moved classes)
3. Move complex classes (with resolved dependencies)
4. Update all imports in affected files
5. Verify no circular dependencies introduced
```

### Import Update Strategy

After moving classes:
1. **DO NOT update imports one by one** (wastes tokens)
2. Use batch approach:
   ```
   - Record all moved classes: OldPath â†’ NewPath
   - Find all files importing old paths
   - Replace all imports in one multi_replace operation
   ```

---

## Phase 3: Validation Strategy (Token-Optimized)

**Goal**: Minimize validation overhead while maintaining safety.

### Batch Validation (Recommended)

Instead of validating after each change, batch by risk level:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Execute ALL Low-Risk Items (Category 1, 5)                 â”‚
â”‚  â†“                                                          â”‚
â”‚  ONE validation checkpoint                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Execute ALL Medium-Risk Items (Category 2)                 â”‚
â”‚  â†“                                                          â”‚
â”‚  ONE validation checkpoint                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Execute ALL Structure Changes (Category 3, 4)              â”‚
â”‚  â†“                                                          â”‚
â”‚  FINAL validation                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Validation Checkpoints

| Checkpoint | When | What to Check |
|------------|------|---------------|
| **Checkpoint 1** | After low-risk batch | Build only (no tests) |
| **Checkpoint 2** | After medium-risk batch | Build + quick syntax check |
| **Checkpoint 3** | After all changes | Full test suite |

### Skip Validation When Safe

**DO NOT run tests for these safe operations:**
- Remove unused imports
- Remove unused variables
- Simplify comments/docs
- Rename private methods (internal only)
- Reorder methods within same class
- Add/remove whitespace

**MUST validate after these risky operations:**
- Change method signatures
- Move methods between classes
- Extract to new class/file
- Change package structure
- Modify public API

### Deferred Test Strategy

```
1. Make ALL code changes first
2. Run IDE error check (instant, no token cost)
3. Run build command ONCE at the end
4. Run tests ONCE at the very end (only if build passes)
```

### Error Recovery

If final validation fails:
1. **DO NOT revert all changes**
2. Use git diff to identify problematic change
3. Fix only the broken part
4. Re-validate only affected scope

---

## Incremental Refactoring Strategy

For large codebases, refactor incrementally:

```
Session 1: Quick wins only (unused code, magic numbers)
Session 2: Documentation cleanup
Session 3: Extract functions/methods within same file
Session 4: Extract utility classes/modules
Session 5: Package/module reorganization
```

Each session must end with:
- Passing build
- One final test run
- Git commit

---

## Safety Checklist (Streamlined)

Before refactoring:
- [ ] Git working tree is clean
- [ ] On feature branch (optional but recommended)

During refactoring:
- [ ] Make all changes in batch
- [ ] Check for IDE errors (red squiggles)
- [ ] NO intermediate test runs

After ALL refactoring complete:
- [ ] Run build once
- [ ] Run tests once (if build passes)
- [ ] Commit all changes together

